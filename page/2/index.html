<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>青蜂侠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="青蜂侠">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="青蜂侠">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="青蜂侠">
<meta name="twitter:description">
  
    <link rel="alternate" href="/feed" title="青蜂侠" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">青蜂侠</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/feed" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-网站开发动静分离实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/static-backend-asolate/" class="article-date">
  <time datetime="2015-12-13T04:46:00.000Z" itemprop="datePublished">2015-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/post/static-backend-asolate/">网站开发动静分离实践</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-动静分离的实现思路"><a href="#1-动静分离的实现思路" class="headerlink" title="1.  动静分离的实现思路"></a>1.  动静分离的实现思路</h3><p>动静分离是将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。</p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/网站动静分离策略.png" alt=""></p>
<p>动静分离的一种做法是将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求全部请求nginx服务器，达到动静分离的目标。</p>
<h4 id="1-1-静态资源部署至CDN上"><a href="#1-1-静态资源部署至CDN上" class="headerlink" title="1.1  静态资源部署至CDN上"></a>1.1  静态资源部署至CDN上</h4><p>我们的方案是直接将静态资源全部存放在CDN服务器上。因为之前项目中的JavaScript,CSS以及img文件都是存放在CDN服务器上，将HTML文件一起存放到CDN上之后，可以将静态资源统一放置在一种服务器上，便于前端进行维护；而且用户在访问静态资源时，可以很好利用CDN的优点——CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p>
<h4 id="1-2-后端API提供数据"><a href="#1-2-后端API提供数据" class="headerlink" title="1.2 后端API提供数据"></a>1.2 后端API提供数据</h4><p>后端应用提供API，根据前端的请求进行处理，并将处理结果通过JSON格式返回至前端。目前应用主要采用Java平台开发，因此应用服务器主要是Tomcat服务器，现在也开始有部分应用采用 node进行开发，应用服务器也开始使用node服务器。</p>
<h4 id="1-3-前后端域名"><a href="#1-3-前后端域名" class="headerlink" title="1.3 前后端域名"></a>1.3 前后端域名</h4><p>动静分离因为静态资源和应用服务分别部署在不同的服务器上，因此会面临域名策略的选择。</p>
<ul>
<li><p>相同域名<br>采用相同域名下，用户请求api时可以避免跨域所带来的问题，相对开发更为快速，工作量也相对小一些。</p>
</li>
<li><p>不同域名<br>前后端采用不同域名时，需要前后端开发时兼容跨域请求的情况，开发量相对上一种会稍多一些。解决跨域方式最常用的方式就是采用JSONP，还有一种解决方式使用CORS（HTTP访问控制）允许某些域名下的跨域请求。<br>目前在我们的项目中JSONP方式更多，CORS因为需要浏览器支持，因此只会在APP内嵌HTML5，且需要POST方式时中使用。</p>
</li>
</ul>
<p>采用不同域名的方式优点也是非常明显的，不同域名采用两个域名服务器，不同的域名服务器根据请求的不同采用不同的负载均衡策略；而且不同域名也可以邮箱方式前端携带过多的Cookie。</p>
<h3 id="2-动静分离的实现优缺点"><a href="#2-动静分离的实现优缺点" class="headerlink" title="2. 动静分离的实现优缺点"></a>2. 动静分离的实现优缺点</h3><h4 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h4><ul>
<li>api接口服务化：动静分离之后，后端应用更为服务化，只需要通过提供api接口即可，可以为多个功能模块甚至是多个平台的功能使用，可以有效的节省后端人力，更便于功能维护。</li>
<li>前后端开发并行：前后端只需要关心接口协议即可，各自的开发相互不干扰，并行开发，并行自测，可以有效的提高开发时间，也可以有些的减少联调时间</li>
<li><p>减轻后端服务器压力，提高静态资源访问速度：后端不用再将模板渲染为html返回给用户端，且静态服务器可以采用更为专业的技术提高静态资源的访问速度。</p>
<h4 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h4></li>
<li><p>不利于网站<a href="https://en.wikipedia.org/wiki/Search_engine_optimization" target="_blank" rel="external">SEO（搜索引擎优化）</a>:搜索引擎的网络爬虫一般是根据url访问页面，获取页面的内容后去掉没用的信息例如：CSS，JavaScript，然后分析剩下的文本内容；动静分离架构模式前端数据即在是由JavaScript来完成，这就会导致网络爬虫得到的信息部分丢失。在开发中可以采用前端缓存不经常变化数据的方式来解决，只有哪些经常发生变化的数据才每次向后端请求。</p>
</li>
<li><p>开发量变大，前后端交流成本升高：后端api返回的数据，往往是有自身逻辑在内的，比如返回数据中的包含status（1-处理中，2-处理成功，3-处理失败），前端需要理解status的不同含义，对应的前端操作需要理解（如，status =1 or status = 2，不可提交）。</p>
</li>
<li>在业务高速发展时需要慎重考虑：因为开发量变大，如果在业务开始阶段，缺乏前端又要求开发速度很快，就需要慎重考虑这种方式的实现成本对业务发展的影响。</li>
</ul>
<h3 id="3-实现案例"><a href="#3-实现案例" class="headerlink" title="3. 实现案例"></a>3. 实现案例</h3><p>这个是在公司做的内嵌到app里的HTML5页面</p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/动静分离示例1.png" alt=""></p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/动静分离示例2.png" alt=""></p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><blockquote>
<p><a href="https://en.wikipedia.org/wiki/CDN" target="_blank" rel="external">CDN wiki</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">CORS</a><br><a href="http://www.cnblogs.com/sharpxiajun/p/4291003.html" target="_blank" rel="external">关于大型网站技术演进的思考（十三）–网站静态化处理—CSI（5）</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/static-backend-asolate/" data-id="cipak1vs1001jy95noxaibwxx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动静分离/">动静分离</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RPC是什么" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/what-is-rpc/" class="article-date">
  <time datetime="2015-12-03T10:12:00.000Z" itemprop="datePublished">2015-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/post/what-is-rpc/">RPC是什么</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-RPC"><a href="#1-RPC" class="headerlink" title="1. RPC"></a>1. <a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="external">RPC</a></h3><p>RPC (Remote Procedure Call)是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。RPC是一个分布式计算的CS模式，总是由Client向Server发出一个执行若干过程请求，Server接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。RPC的协议有很多，比如最早的CORBA，Java RMI，Web Service的RPC风格，Hessian，Thrift，甚至Rest API。</p>
<h4 id="1-1-RPC的调用流程"><a href="#1-1-RPC的调用流程" class="headerlink" title="1.1 RPC的调用流程"></a>1.1 RPC的调用流程</h4><p><img src="http://7xkbey.com1.z0.glb.clouddn.com/RPC原理.png" alt="">图片来自<a href="http://blog.jobbole.com/92290/" target="_blank" rel="external">你应该知道的RPC原理</a></p>
<ul>
<li>服务消费方（client）调用以本地调用方式调用服务； </li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </li>
<li>client stub找到服务地址，并将消息发送到服务端； </li>
<li>server stub收到消息后进行解码； </li>
<li>server stub根据解码结果调用本地的服务； </li>
<li>本地服务执行并将结果返回给server stub； </li>
<li>server stub将返回结果打包成消息并发送至消费方； </li>
<li>client stub接收到消息，并进行解码； </li>
<li>服务消费方得到最终结果。 </li>
</ul>
<p>RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。 </p>
<h4 id="1-2-RPC需要解决的问题"><a href="#1-2-RPC需要解决的问题" class="headerlink" title="1.2 RPC需要解决的问题"></a>1.2 RPC需要解决的问题</h4><ul>
<li>通讯的问题</li>
<li>服务寻址的问题</li>
<li>参数的序列化和反序列化</li>
<li>负载均衡的问题</li>
</ul>
<h3 id="2-服务通信协议"><a href="#2-服务通信协议" class="headerlink" title="2. 服务通信协议"></a>2. 服务通信协议</h3><p>服务通信主要是Client和Server之间建立网络连接，所有交换的数据都在这个连接里传输，连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。不同的RPC框架可能使用不同的网络协议，常用的有直接使用TCP，基于HTTP/HTTP2.0 等，目前pigeon使用的有TCP和HTTP协议。在java领域一些工具和框架已经封装对底层协议的使用进行了封装例如比较著名的<a href="http://netty.io/" target="_blank" rel="external">Netty</a>(这也是pigeon在使用的通信框架），<a href="https://mina.apache.org/" target="_blank" rel="external">Apache MINA</a></p>
<h3 id="3-服务寻址"><a href="#3-服务寻址" class="headerlink" title="3. 服务寻址"></a>3. 服务寻址</h3><p>每次Client向Server端发起请求之前，需要知道该向哪个Server发请求，也就涉及到服务寻址的问题。最简单的方式是直接指定Server的ip,访问特定机器上的服务。</p>
<p>但是在分布式环境中，通过在代码中指定ip的方式是不合适的，所以现在的RPC框架基本都是使用配置的方式来实现服务的寻址。配置方式下涉及Server端服务的注册和Client端的服务寻址，这里就成为了Zookeeper应用的绝佳场景。</p>
<h4 id="3-1-ZooKeeper-管理分布式服务配置"><a href="#3-1-ZooKeeper-管理分布式服务配置" class="headerlink" title="3.1 ZooKeeper 管理分布式服务配置"></a>3.1 ZooKeeper 管理分布式服务配置</h4><p>ZooKeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。ZooKeeper的架构通过冗余服务实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。<br><img src="http://7xkbey.com1.z0.glb.clouddn.com/zookeerp数据模型.gif" alt=""><br>图片来自<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="external">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a></p>
<p>3.1.1 <strong>服务注册</strong><br>    当每次Server启动时，想调用ZooKeeper的Client，将自身提供的服务注册到ZooKeeper中，形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://service.test.com/demoservice/demo_1.0.0:127.0.0.1</span><br></pre></td></tr></table></figure>
<p>当Server Shut down 时也会将自身节点在ZooKeeper配置中进行摘除。</p>
<p>3.1.2 <strong>服务寻址</strong></p>
<p>Client每次请求Server之前，需要向ZooKeeper中查询该服务对应的地址，例如需要使用demoservice，查询key为<a href="http://service.test.com/demoservice/demo_1.0.0的对应ip，即可访问对应服务。" target="_blank" rel="external">http://service.test.com/demoservice/demo_1.0.0的对应ip，即可访问对应服务。</a></p>
<p>3.1.3 <strong>服务修改广播</strong></p>
<p>当一个服务发生修改时，如服务的启动与关闭，都会将消息发送到感兴趣的Client。</p>
<p>ZooKeeper的原理及使用参见 <a href="https://zookeeper.apache.org/" target="_blank" rel="external">ZooKeeper项目</a></p>
<h3 id="4-序列化及反序列化"><a href="#4-序列化及反序列化" class="headerlink" title="4. 序列化及反序列化"></a>4. 序列化及反序列化</h3><p>Client找到对应Server之后就需要传递参数到Server端，Server在处理完数据之后也需要将结果返回给Client。</p>
<p>每种序列化协议都有不同的优点和确定，一个成熟的序列化协议需要通盘考虑通用性，强健性，可调试性/可读性，性能，可扩展性以及安全性等方面。目前常见的序列化协议主要有<a href="http://hessian.caucho.com/" target="_blank" rel="external">hessian</a>，XML、JSON、<a href="https://github.com/google/protobuf" target="_blank" rel="external">Protobuf</a>、<a href="https://thrift.apache.org/" target="_blank" rel="external">Thrift</a>和<a href="https://avro.apache.org/" target="_blank" rel="external">Avro</a>。</p>
<p>例如，<a href="https://github.com/wu-xiang/pigeon" target="_blank" rel="external">pigeon</a>支持多种序列化方式，序列化方式只需要在客户端调用时通过serialize属性指定，一般情况推荐兼容性最好的hessian。<br>如果需要自行设计序列化方式，可以继承com.dianping.pigeon.remoting.common.codec.DefaultAbstractSerializer类来定义自己的序列化类，并通过SerializerFactory.registerSerializer(byte serializerType, Serializer serializer)接口将自定义的序列化类注册进来。</p>
<h3 id="5-负载均衡"><a href="#5-负载均衡" class="headerlink" title="5. 负载均衡"></a>5. 负载均衡</h3><p>负载平衡（Load balancing）是一种计算机网络技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最佳化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。负载均衡器有各种各样的工作排程算法（用于决定将前端用户请求发送到哪一个后台服务器），最简单的是随机选择和轮询。更为高级的负载均衡器会考虑其它更多的相关因素，如后台服务器的负载，响应时间，运行状态，活动连接数，地理位置，处理能力，或最近分配的流量。</p>
<p>例如，<a href="https://github.com/wu-xiang/pigeon" target="_blank" rel="external">pigeon</a>支持random、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%88%B6" target="_blank" rel="external">roundRobin</a>、weightedAutoware这几种类型，默认weighted Autoware策略。在pigeon框架中在每一次发送请求时都会有在线程中计算请求的返回时间，weighted Autoware策略是根据各个线程统计的响应时间来判断该服务的负载情况，响应时间越长说明该机器的负载越重。</p>
<h3 id="6-容灾"><a href="#6-容灾" class="headerlink" title="6. 容灾"></a>6. 容灾</h3><p>这里我们主要以<a href="https://github.com/wu-xiang/pigeon" target="_blank" rel="external">pigeon</a>为例介绍其实现容灾的方式，以供参考。</p>
<h4 id="6-1-健康检测"><a href="#6-1-健康检测" class="headerlink" title="6.1 健康检测"></a>6.1 健康检测</h4><p>在pigeon中，当使用tcp协议连接是，Client会定期发送心跳消息和接收心跳消息，如果心跳未正常返回，则在Client端会摘除这个Server节点，在后续服务寻址时不再选择该Server节点。</p>
<h4 id="6-2-超时及重试"><a href="#6-2-超时及重试" class="headerlink" title="6.2 超时及重试"></a>6.2 超时及重试</h4><p>Client端可以配置一个服务的超时时间，当发送请求是，pigeon线程会计算该请求所耗费的时间，如果超过限制时间尚未返回，则根据配置返回超时或者进行重试，避免客户端过长时间的等待。</p>
<h4 id="6-3-客户端配置集群策略模式"><a href="#6-3-客户端配置集群策略模式" class="headerlink" title="6.3 客户端配置集群策略模式"></a>6.3 客户端配置集群策略模式</h4><p>pigeon 的客户端集群策略有failfast、failover、failsafe和forking 四种方式。 </p>
<ul>
<li>failfast-调用服务的一个节点失败后抛出异常返回</li>
<li>failover-调用服务的一个节点失败后会尝试调用另外的一个节点</li>
<li>failsafe-调用服务的一个节点失败后不会抛出异常，返回null，后续版本会考虑按配置默认值返回</li>
<li>forking-同时调用服务的所有可用节点，返回调用最快的节点结果数据</li>
</ul>
<h4 id="6-4-服务隔离与限流"><a href="#6-4-服务隔离与限流" class="headerlink" title="6.4 服务隔离与限流"></a>6.4 服务隔离与限流</h4><ul>
<li>配置服务方法级别的最大并发数</li>
<li>限制某个客户端应用的最大并发数<br>详情参见<a href="http://code.dianpingoa.com/arch/pigeon2/blob/master/pigeon-governor/pigeon-governor-server/src/main/webapp/resources/mdwiki/USER_GUIDE.md" target="_blank" rel="external">Pigeon开发指南</a>。</li>
</ul>
<h3 id="7-目前常见的RPC框架"><a href="#7-目前常见的RPC框架" class="headerlink" title="7. 目前常见的RPC框架"></a>7. 目前常见的RPC框架</h3><ul>
<li><a href="http://hessian.caucho.com/" target="_blank" rel="external">Hessian</a></li>
</ul>
<p>除了hessian协议之外，还提供了通过servlet方式实现的RPC框架</p>
<ul>
<li><a href="https://thrift.apache.org/" target="_blank" rel="external">Thrift</a></li>
</ul>
<p>Thrift是一个跨语言的服务部署框架，最初由Facebook于2007年开发，2008年进入Apache开源项目。Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码（目前支持C++,Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk和OCaml）,并由生成的代码负责RPC协议层和传输层的实现。</p>
<ul>
<li><a href="https://twitter.github.io/finagle/" target="_blank" rel="external">Finagle</a></li>
</ul>
<p>Finagle是Twitter基于Netty开发的支持容错的、协议无关的RPC框架，该框架支撑了Twitter的核心服务。</p>
<ul>
<li><a href="https://github.com/alibaba/dubbo" target="_blank" rel="external">Dubbo</a><br>Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</li>
</ul>
<ul>
<li><a href="http://www.grpc.io/" target="_blank" rel="external">gRPC</a></li>
</ul>
<p>gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。gRPC提供了一种简单的方法来精确地定义服务和为iOS、Android和后台支持服务自动生成可靠性很强的客户端功能库。客户端充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用、和电池寿命。</p>
<h3 id="8-RPC-与-微服务-MicroService"><a href="#8-RPC-与-微服务-MicroService" class="headerlink" title="8. RPC 与 微服务(MicroService)"></a>8. RPC 与 微服务(MicroService)</h3><p>微服务是一种架构思想，一个微服务一般只完成某个特定的功能，比如下单服务，订单查询服务，是将应用分解为小的，相互连接的服务。</p>
<p>微服务在系统层面有多种多样的表现形式，例如暴露restful api，SOA服务或者http接口。RPC可以作为实现微服务系统的一种实现方式将各个应用都暴露出RPC的服务接口，从而实现微服务的架构。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><blockquote>
<p><a href="https://github.com/wu-xiang/pigeon" target="_blank" rel="external">pigeon框架</a><br><a href="https://github.com/wu-xiang/pigeon/blob/master/USER_GUIDE.md" target="_blank" rel="external">pigeon user guide</a><br><a href="http://itindex.net/detail/52530-rpc-%E6%A1%86%E6%9E%B6-%E5%88%86%E6%9E%90" target="_blank" rel="external">RPC调用框架比较分析</a><br><a href="http://itindex.net/detail/53322-rpc-%E6%A1%86%E6%9E%B6-bangerlee" target="_blank" rel="external">RPC框架实现 - 容灾篇 - bangerlee</a><br>﻿<br><a href="http://itindex.net/detail/52896-rpc-%E5%8E%9F%E7%90%86" target="_blank" rel="external">RPC原理详解 - 永志</a><br><a href="http://itindex.net/detail/54558-rpc-%E5%8E%9F%E7%90%86" target="_blank" rel="external">你应该知道的RPC原理</a></p>
<p><a href="http://www.infoq.com/cn/news/2014/05/twitter-finagle-intro" target="_blank" rel="external">Twitter的RPC框架Finagle简介</a><br><a href="http://www.infoq.com/cn/news/2015/03/grpc-google-http2-protobuf" target="_blank" rel="external">gRPC：Google开源的基于HTTP/2和ProtoBuf的通用RPC框架</a></p>
<p><a href="https://zookeeper.apache.org/" target="_blank" rel="external"> Apache ZooKeeper</a><br><a href="https://zookeeper.apache.org/doc/trunk/" target="_blank" rel="external">Apache ZooKeeper doc</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="external">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/" target="_blank" rel="external">Google Protocol Buffer 的使用和原理</a><br><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">Protocol Buffers</a><br><a href="https://blog.twitter.com/2014/netty-at-twitter-with-finagle" target="_blank" rel="external">Netty at Twitter with Finagle</a><br><a href="http://www.infoq.com/cn/news/2014/05/twitter-finagle-intro" target="_blank" rel="external">Twitter的RPC框架Finagle简介</a></p>
<p><a href="https://dzone.com/articles/goodbye-microservices-hello-right-sized-services?edition=99055" target="_blank" rel="external">Goodbye Microservices, Hello Right-sized Services</a><br><a href="http://www.infoq.com/cn/news/2013/12/micro-service-architecture" target="_blank" rel="external">微服务架构解析</a><br><a href="http://www.infoq.com/cn/news/2015/04/micro-service-architecture" target="_blank" rel="external">微服务架构的设计模式</a><br><a href="http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-02" target="_blank" rel="external">解析微服务架构（二）微服务架构综述</a><br><a href="http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-01" target="_blank" rel="external">解析微服务架构（一）单块架构系统以及其面临的挑战</a><br><a href="http://dockone.io/article/394" target="_blank" rel="external">微服务实战（一）：微服务架构的优势与不足</a><br><a href="http://www.infoq.com/cn/news/2015/04/single-app-micro-service" target="_blank" rel="external">单体应用与微服务优缺点辨析</a><br><a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design" target="_blank" rel="external">SOLID</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/what-is-rpc/" data-id="cipak1vq5000jy95ncuuzbkoz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rpc-pigeon/">rpc pigeon</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-多台服务器查询日志" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/undefined/" class="article-date">
  <time datetime="2015-11-27T03:26:00.000Z" itemprop="datePublished">2015-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/post/undefined/">多台服务器查询日志</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>互联网行业基本都是采用分布式部署，一个应用有很多台服务器，多的会有上百台。一旦线上出现case，很可能需要查询日志，但是一下子这么多机器查起来费时费事。<br>现在我们使用下面的脚本直接就可以拉到相关机器的日志。</p>
<h3 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h3><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>加入我们有sb1,sb2,sb3三台机器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> server <span class="keyword">in</span> sb1 sb2 sb3; <span class="keyword">do</span></span><br><span class="line">ssh <span class="string">"<span class="variable">$server</span>"</span> grep <span class="string">'test'</span> /data/applogs/sb/app.lot</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>这样一下就可以拉到所有机器的日志</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这段代码有个小问题，一般线上服务器都需要用户名和密码，用户名在ssh中可以很轻松的带上，但是每次输入密码是件很痛苦的事情，可以考虑<a href="http://www-01.ibm.com/support/knowledgecenter/ssw_aix_71/com.ibm.aix.cmds3/kinit.htm?lang=zh" target="_blank" rel="external">kinit</a>的方式保存帐号和密码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/undefined/" data-id="cipak1vrb0013y95ntv7eb558" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-我们需要什么样的微服务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/which-kind-microservice-weneed/" class="article-date">
  <time datetime="2015-11-26T11:46:00.000Z" itemprop="datePublished">2015-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/post/which-kind-microservice-weneed/">我们需要什么样的微服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>微服务到底应该是多大，一种简单的划分方法是项目代码在100-300行。这个划分方式肯定是不合理的，但也表现了微服务的一个核心思想——服务尽量的小。</p>
<h3 id="1-微服务架构的特点"><a href="#1-微服务架构的特点" class="headerlink" title="1. 微服务架构的特点"></a>1. 微服务架构的特点</h3><ul>
<li>领域驱动设计</li>
<li>单一职责原则：每个服务只负责自己单独的部分，这也是SOLID原则之一；</li>
<li>明确发布接口：每个服务都会发布一个定义明确的接口，消费者只需要关心接口即可；</li>
<li>独立部署、升级、扩展和替换：每个服务都可以单独部署及重新部署而不影响整个系统。这使得服务很容易升级；</li>
<li>服务相互解耦；</li>
<li>轻量级通信：服务通信使用轻量级的通信协议，例如，同步的REST，异步的AMQP、STOMP、MQTT等。</li>
</ul>
<p>这些使得微服务具有以下优点：</p>
<ul>
<li>开发易于开发、理解和维护</li>
<li>比单体应用启动快，</li>
<li>局部修改很容易部署，</li>
<li>故障隔离，一个服务出现问题不会影响整个应用，</li>
<li>不会受限于任何技术栈</li>
</ul>
<p>这些让微服务看起来像是银弹一样，但是微服务更多的是将开发的工作量推到了运维侧，采用微服务架构使得运维工作量巨大。</p>
<p>另外微服务使得接口升级的工作量也非常大，因为一旦接口的定义发生修改，则会影响到所以使用此接口的其他系统，所以升级中需要考虑到升级的各种影响，反而使得上线的成本进一步加大。</p>
<h3 id="2-微服务的设计模式1"><a href="#2-微服务的设计模式1" class="headerlink" title="2. 微服务的设计模式1"></a>2. 微服务的设计模式<a href="http://www.infoq.com/cn/news/2015/04/micro-service-architecture" target="_blank" rel="external">1</a></h3><h4 id="2-1-聚合器微服务设计模式"><a href="#2-1-聚合器微服务设计模式" class="headerlink" title="2.1 聚合器微服务设计模式"></a>2.1 聚合器微服务设计模式</h4><p><img src="http://cdn3.infoqstatic.com/statics_s2_20151125-0108-1/resource/news/2015/04/micro-service-architecture/zh/resources/1.png" alt=""></p>
<p>聚合器调用多个服务实现应用程序所需的功能。它可以是一个简单的Web页面，将检索到的数据进行处理展示。它也可以是一个更高层次的组合微服务，对检索到的数据增加业务逻辑后进一步发布成一个新的微服务，这符合DRY原则。另外，每个服务都有自己的缓存和数据库。如果聚合器是一个组合服务，那么它也有自己的缓存和数据库。聚合器可以沿X轴和Z轴独立扩展。</p>
<h4 id="2-2-代理微服务设计模式"><a href="#2-2-代理微服务设计模式" class="headerlink" title="2.2 代理微服务设计模式"></a>2.2 代理微服务设计模式</h4><p><img src="http://cdn3.infoqstatic.com/statics_s2_20151125-0108-1/resource/news/2015/04/micro-service-architecture/zh/resources/2.png" alt=""></p>
<p>在这种情况下，客户端并不聚合数据，但会根据业务需求的差别调用不同的微服务。代理可以仅仅委派请求，也可以进行数据转换工作。</p>
<h4 id="2-3-链式微服务设计模式"><a href="#2-3-链式微服务设计模式" class="headerlink" title="2.3 链式微服务设计模式"></a>2.3 链式微服务设计模式</h4><p><img src="http://cdn3.infoqstatic.com/statics_s2_20151125-0108-1/resource/news/2015/04/micro-service-architecture/zh/resources/3.png" alt=""></p>
<p>在这种情况下，服务A接收到请求后会与服务B进行通信，类似地，服务B会同服务C进行通信。所有服务都使用同步消息传递。在整个链式调用完成之前，客户端会一直阻塞。因此，服务调用链不宜过长，以免客户端长时间等待。</p>
<h4 id="2-4-分支微服务设计模式"><a href="#2-4-分支微服务设计模式" class="headerlink" title="2.4 分支微服务设计模式"></a>2.4 分支微服务设计模式</h4><p><img src="http://cdn3.infoqstatic.com/statics_s2_20151125-0108-1/resource/news/2015/04/micro-service-architecture/zh/resources/4.png" alt=""></p>
<p>这种模式是聚合器模式的扩展，允许同时调用两个微服务链。</p>
<h4 id="2-5-数据共享微服务设计模式"><a href="#2-5-数据共享微服务设计模式" class="headerlink" title="2.5 数据共享微服务设计模式"></a>2.5 数据共享微服务设计模式</h4><p><img src="http://cdn3.infoqstatic.com/statics_s2_20151125-0108-1/resource/news/2015/04/micro-service-architecture/zh/resources/5.png" alt=""></p>
<p>自治是微服务的设计原则之一，就是说微服务是全栈式服务。但在重构现有的“单体应用（monolithic application）”时，SQL数据库反规范化可能会导致数据重复和不一致。在这种情况下，部分微服务可能会共享缓存和数据库存储。不过，这只有在两个服务之间存在强耦合关系时才可以。对于基于微服务的新建应用程序而言，这是一种反模式。</p>
<h4 id="2-6-异步消息传递微服务设计模式"><a href="#2-6-异步消息传递微服务设计模式" class="headerlink" title="2.6 异步消息传递微服务设计模式"></a>2.6 异步消息传递微服务设计模式</h4><p><img src="http://cdn3.infoqstatic.com/statics_s2_20151125-0108-1/resource/news/2015/04/micro-service-architecture/zh/resources/6.png" alt=""><br>虽然REST设计模式非常流行，但它是同步的，会造成阻塞。因此部分基于微服务的架构可能会选择使用消息队列代替REST请求/响应。</p>
<h3 id="3-我们需要何种大小的服务"><a href="#3-我们需要何种大小的服务" class="headerlink" title="3. 我们需要何种大小的服务"></a>3. 我们需要何种大小的服务</h3><p>微服务的小该小到何种地步，按照代码行数来划分，在300行一下。这种划分方式有一定道理，但这种方式显然是不合理的，因为不同的语言在写起功能来所需的行数是不一样的。<br>划分微服务最好的方式是按照系统的边界（领域）来划分。比如a服务只负责创建订单，b服务只负责查询订单。系统的实现大小根据业务领域的需求而变化，如果业务领域慢慢变大，则可以将业务领域继续细分，如创建订单服务，又可以划分为创建酒店订单，创建电影订单，随着业务的需要而不断细分。<br><img src="http://7xkbey.com1.z0.glb.clouddn.com/微服务系统.png" alt=""></p>
<h3 id="4-服务分级"><a href="#4-服务分级" class="headerlink" title="4. 服务分级"></a>4. 服务分级</h3><p>微服务虽小，也是有级别的。简单划分可以按照服务的依赖情况来划分：</p>
<ul>
<li>基础服务<br>这种服务除了对数据库的依赖之外就不再依赖其他的微服务，只向外提供接口。</li>
<li>集成服务<br>集成服务是指主要依赖与其他服务（基础服务和集成服务）进行业务处理，更多的是作为流程管理的角色，一般不维护自身数据。例如用户提交订单，集成服务首先去调用验证服务，之后再调用创建订单服务。<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3></li>
</ul>
<blockquote>
<p><a href="https://dzone.com/articles/goodbye-microservices-hello-right-sized-services?edition=99055" target="_blank" rel="external">Goodbye Microservices, Hello Right-sized Services</a><br><a href="http://www.infoq.com/cn/news/2013/12/micro-service-architecture" target="_blank" rel="external">微服务架构解析</a><br><a href="http://www.infoq.com/cn/news/2015/04/micro-service-architecture" target="_blank" rel="external">微服务架构的设计模式</a><br><a href="http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-02" target="_blank" rel="external">解析微服务架构（二）微服务架构综述</a><br><a href="http://www.infoq.com/cn/articles/analysis-the-architecture-of-microservice-part-01" target="_blank" rel="external">解析微服务架构（一）单块架构系统以及其面临的挑战</a><br><a href="http://dockone.io/article/394" target="_blank" rel="external">微服务实战（一）：微服务架构的优势与不足</a><br><a href="http://www.infoq.com/cn/news/2015/04/single-app-micro-service" target="_blank" rel="external">单体应用与微服务优缺点辨析</a><br><a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design" target="_blank" rel="external">SOLID</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/which-kind-microservice-weneed/" data-id="cipak1vrj0017y95nftfq79lu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/microservice/">microservice</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL索引及查询优化.comments" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/undefined/" class="article-date">
  <time datetime="2015-09-29T10:05:46.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>date: 2015-09-29 18:02:23<br>author: Shrek<br>email: csslog@gmail.com<br>site: <a href="http://muguayuan.com" target="_blank" rel="external">http://muguayuan.com</a><br>ip: 107.161.26.240</p>
<p>下班回家好好看</p>
<hr>
<p>date: 2015-09-30 14:05:19<br>author: newbmiao<br>email: newbvirgil@gmail.com<br>site: <a href="http://blog.newbmiao.com/" target="_blank" rel="external">http://blog.newbmiao.com/</a><br>ip: 124.193.183.162</p>
<p>涨知识了！</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/undefined/" data-id="cipak1vp30004y95nmaghteug" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-接口幂等性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/api-idempotent/" class="article-date">
  <time datetime="2015-09-29T08:06:00.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/post/api-idempotent/">分布式系统接口幂等性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-幂等性定义"><a href="#1-幂等性定义" class="headerlink" title="1.幂等性定义"></a>1.幂等性定义</h3><h4 id="1-1-数学定义"><a href="#1-1-数学定义" class="headerlink" title="1.1 数学定义"></a>1.1 数学定义</h4><blockquote>
<p>在数学里，幂等有两种主要的定义：</p>
<ul>
<li>在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。<br>即 s *s = s</li>
<li>某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的，即f(f(x)) = f(x)。</li>
</ul>
</blockquote>
<h4 id="1-2-HTTP规范的定义"><a href="#1-2-HTTP规范的定义" class="headerlink" title="1.2 HTTP规范的定义"></a>1.2 HTTP规范的定义</h4><p> 在HTTP/1.1规范中幂等性的定义是：</p>
<blockquote>
<p>A request method is considered “idempotent” if the intended effect onthe server of multiple identical requests with that method is the same as the effect for a single such request.  Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent.</p>
</blockquote>
<p>HTTP的幂等性指的是一次和多次请求某一个资源应该具有相同的副作用。如通过PUT接口将数据的Status置为1，无论是第一次执行还是多次执行，获取到的结果应该是相同的，即执行完成之后Status =1。</p>
<h3 id="2-何种接口提供幂等性"><a href="#2-何种接口提供幂等性" class="headerlink" title="2. 何种接口提供幂等性"></a>2. 何种接口提供幂等性</h3><h4 id="2-1-HTTP支持幂等性的接口"><a href="#2-1-HTTP支持幂等性的接口" class="headerlink" title="2.1 HTTP支持幂等性的接口"></a>2.1 HTTP支持幂等性的接口</h4><p>在HTTP规范中定义GET,PUT和DELETE方法应该具有幂等性。</p>
<ul>
<li>GET方法</li>
</ul>
<blockquote>
<p>The GET method requests transfer of a current selected representatiofor the target resourceGET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.</p>
</blockquote>
<p>GET方法是向服务器查询，不会对系统产生副作用，具有幂等性（<strong><font style="color:red;">不代表每次请求都是相同的结果</font></strong>)</p>
<ul>
<li>PUT方法</li>
</ul>
<blockquote>
<p>T he PUT method requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload.</p>
</blockquote>
<p>也就是说PUT方法首先判断系统中是否有相关的记录，如果有记录则更新该记录，如果没有则新增记录。</p>
<ul>
<li>DELETE 方法</li>
</ul>
<blockquote>
<p> The DELETE method requests that the origin server remove the association between the target resource and its current functionality.  In effect, this method is similar to the rm command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted.</p>
</blockquote>
<p>DELETE方法是删除服务器上的相关记录。</p>
<h4 id="2-2-实际业务"><a href="#2-2-实际业务" class="headerlink" title="2.2 实际业务"></a>2.2 实际业务</h4><p>现在简化为这样一个系统，用户购买商品的订单系统与支付系统；订单系统负责记录用户的购买记录已经订单的流转状态（orderStatus),支付系统用于付款，提供<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> accountid,BigDecimal amount)</span> <span class="comment">//用于付款，扣除用户的</span></span></span><br></pre></td></tr></table></figure></p>
<p>接口，订单系统与支付系统通过分布式网络交互。</p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/订单幂等性.png" alt=""></p>
<p>这种情况下，支付系统已经扣款，但是订单系统因为网络原因，没有获取到确切的结果，因此订单系统需要重试。<br>由上图可见，支付系统并没有做到接口的幂等性，订单系统第一次调用和第二次调用，用户分别被扣了两次钱，不符合幂等性原则（同一个订单，无论是调用了多少次，用户都只会扣款一次）。<br>如果需要支持幂等性，付款接口需要修改为以下接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> orderId,<span class="keyword">int</span> accountId,BigDecimal amount)</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过orderId来标定订单的唯一性，付款系统只要检测到订单已经支付过，则第二次调用不会扣款而会直接返回结果：</p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/订单支持幂等.png" alt=""></p>
<p>在不同的业务中不同接口需要有不同的幂等性，特别是在分布式系统中，因为网络原因而未能得到确定的结果，往往需要支持接口幂等性。</p>
<h3 id="3-分布式系统接口幂等性"><a href="#3-分布式系统接口幂等性" class="headerlink" title="3.分布式系统接口幂等性"></a>3.分布式系统接口幂等性</h3><p>随着分布式系统及微服务的普及，因为网络原因而导致调用系统未能获取到确切的结果从而导致重试，这就需要被调用系统具有幂等性。<br>例如上文所阐述的支付系统，针对同一个订单保证支付的幂等性，一旦订单的支付状态确定之后，以后的操作都会返回相同的结果，对用户的扣款也只会有一次。这种接口的幂等性，简化到数据层面的操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> userAmount <span class="keyword">set</span> amount = amount - <span class="string">'value'</span> ,paystatus = <span class="string">'paid'</span> <span class="keyword">where</span> orderId= <span class="string">'orderid'</span> <span class="keyword">and</span> paystatus = <span class="string">'unpay'</span></span><br></pre></td></tr></table></figure></p>
<p>其中value是用户要减少的订单，paystatus代表支付状态，paid代表已经支付，unpay代表未支付，orderid是订单号。<br>在上文中提到的订单系统，订单具有自己的状态（orderStatus),订单状态存在一定的流转。订单首先有提交（0），付款中（1），付款成功（2），付款失败（3），简化之后其流转路径如图：<br><img src="http://7xkbey.com1.z0.glb.clouddn.com/订单状态流转的幂等性.png" alt=""><br>当orderStatus = 1 时，其前置状态只能是0，也就是说将orderStatus由0-&gt;1 是需要幂等性的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">Order</span> <span class="keyword">set</span> orderStatus = <span class="number">1</span> <span class="keyword">where</span> OrderId = <span class="string">'orderid'</span> <span class="keyword">and</span> orderStatus = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>当orderStatus 处于0，1两种状态时，对订单执行0-&gt;1 的状态流转操作应该是具有幂等性的。<br>这时候需要在执行update操作之前检测orderStatus是否已经=1，如果已经=1则直接返回true即可。</p>
<p>但是如果此时orderStatus = 2,再进行订单状态0-&gt;1 时操作就无法成功，但是幂等性是针对同一个请求的，也就是针对同一个requestid保持幂等。</p>
<p>这时候再执行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">Order</span> <span class="keyword">set</span> orderStatus = <span class="number">1</span> <span class="keyword">where</span> OrderId = <span class="string">'orderid'</span> <span class="keyword">and</span> orderStatus = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>接口会返回失败，系统没有产生修改，如果再发一次，requestid是相同的，对系统同样没有产生修改。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%86%AA%E7%AD%89" target="_blank" rel="external">幂等</a><br><a href="http://coolshell.cn/articles/4787.html" target="_blank" rel="external">HTTP幂等性概念和应用</a><br><a href="http://www.infoq.com/news/2013/04/idempotent" target="_blank" rel="external">What Is Idempotent in REST?</a><br><a href="http://www.infoq.com/cn/news/2013/05/idempotent" target="_blank" rel="external">REST之中的幂等指的是什么？</a><br><a href="http://tools.ietf.org/html/rfc7231#section-4.2" target="_blank" rel="external">Hypertext Transfer Protocol (HTTP/1.1)</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/api-idempotent/" data-id="cipak1vrm0019y95ngo2vb8mo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Idempotent/">Idempotent</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL索引及查询优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/mysql-index-query/" class="article-date">
  <time datetime="2015-09-29T07:48:00.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/post/mysql-index-query/">MySQL索引及查询优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-MySQL索引的原理"><a href="#1-MySQL索引的原理" class="headerlink" title="1. MySQL索引的原理"></a>1. MySQL索引的原理</h3><h4 id="1-1-索引目的"><a href="#1-1-索引目的" class="headerlink" title="1.1 索引目的"></a>1.1 索引目的</h4><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？</p>
<h4 id="1-2-索引原理"><a href="#1-2-索引原理" class="headerlink" title="1.2 索引原理"></a>1.2 索引原理</h4><p>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。<br>每个数据表都有一个主键（<em>如果没有主键，数据库会将该表中的唯一索引当作主键使用？</em>），MySQL会以主键的方式构造一棵树，叶子节点存放该主键对应的整行数据。<br><img src="http://7xkbey.com1.z0.glb.clouddn.com/表.png" alt=""><br>自己建立的索引，一般叫做辅助索引，辅助索引的树，也自己节点存放了两个东西，一个是索引自身的值，另外一个是索引对应主键的值。<br><img src="http://7xkbey.com1.z0.glb.clouddn.com/索引.png" alt=""></p>
<p>如果索引是联合索引，比如UserID和AddTime索引的方式，索引叶子节点会存储UserID和AddTime之间的配对+主键的配对数据。</p>
<h4 id="1-3-索引的类型"><a href="#1-3-索引的类型" class="headerlink" title="1.3 索引的类型"></a>1.3 索引的类型</h4><h5 id="1-3-1-B-树索引"><a href="#1-3-1-B-树索引" class="headerlink" title="1.3.1 B-树索引"></a>1.3.1 B-树索引</h5><p><strong>B-树索引在生产环境更为广泛，这里我只针对B-树索引进行讨论</strong><br>B-树索引是一个复杂的内容，可以参见<a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="external">B-tree</a>。</p>
<h5 id="1-3-2-Hash索引"><a href="#1-3-2-Hash索引" class="headerlink" title="1.3.2 Hash索引"></a>1.3.2 Hash索引</h5><p>哈希索引（Hash Index）建立在哈希表的基础上，它只对使用了索引中的每一列的精确查找有用。对于每一行，存储引擎计算出了被索引的哈希码（Hash Code），它是一个较小的值，并且有可能和其他行的哈希码不同。它把哈希码保存在索引中，并且保存了一个指向哈希表中的每一行的指针。</p>
<p>在mysql中，只有memory存储引擎支持显式的哈希索引。</p>
<ul>
<li>Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</li>
<li>Hash 索引无法被用来避免数据的排序操作。</li>
<li>Hash 索引不能利用部分索引键查询。</li>
<li>Hash 索引在任何时候都不能避免表扫描。</li>
<li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高</li>
</ul>
<h5 id="1-3-3-空间索引（R-树）索引"><a href="#1-3-3-空间索引（R-树）索引" class="headerlink" title="1.3.3  空间索引（R-树）索引"></a>1.3.3  空间索引（R-树）索引</h5><p>主要用于GIS中空间数据的存储，但是MySQL的空间索引支持并不好，现在多使用PostgreSQL。</p>
<h5 id="1-3-4-全文索引-Full-text-索引"><a href="#1-3-4-全文索引-Full-text-索引" class="headerlink" title="1.3.4  全文索引(Full-text)索引"></a>1.3.4  全文索引(Full-text)索引</h5><p>文本字段上的普通索引只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成 的较大段文字，普通索引就没什么作用了。这种检索往往以LIKE %word%的形式出现，这对MySQL来说很复杂，如果需要处理的数据量很大，响应时间就会很长。</p>
<p>这类场合正是全文索引(full-text index)可以大显身手的地方。在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数 据记录。全文索引即可以随数据表一同创建，也可以等日后有必要时再使用下面这条命令添加：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> FULLTEXT(column1, column2)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-索引的合理使用"><a href="#2-索引的合理使用" class="headerlink" title="2. 索引的合理使用"></a>2. 索引的合理使用</h3><table>
<thead>
<tr>
<th style="text-align:center">字段名</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:right">NULL</th>
<th style="text-align:center">INDEX</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ID</td>
<td style="text-align:center">int(10)</td>
<td style="text-align:right">NOT NULL</td>
<td style="text-align:center">pk</td>
</tr>
<tr>
<td style="text-align:center">UserID</td>
<td style="text-align:center">int(10)</td>
<td style="text-align:right">NOT NULL</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Mobile</td>
<td style="text-align:center">varchar(15)</td>
<td style="text-align:right">NOT NULL</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ArriveDate</td>
<td style="text-align:center">DateTime</td>
<td style="text-align:right">NOT NULL</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">AddDate</td>
<td style="text-align:center">DateTime</td>
<td style="text-align:right">NOT NULL</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">UpdateTime</td>
<td style="text-align:center">timetamp</td>
<td style="text-align:right">NOT NULL</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>下面我们的分析都会这个数据表为例。</p>
<h4 id="2-1-索引在查询中的使用"><a href="#2-1-索引在查询中的使用" class="headerlink" title="2.1 索引在查询中的使用"></a>2.1 索引在查询中的使用</h4><p><strong>不使用索引</strong></p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/数据.png" alt=""></p>
<p>现在刚建立的表上没有任何索引，但是我们想通过UserID找出ArriveDate这个数据，SQL将会写成如下方式：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ArriveDate <span class="keyword">from</span> TestSQL <span class="keyword">where</span> UserID = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/无索引分析.png" alt=""></p>
<p>这个SQL没有走索引，数据库就会根据主键（ID）扫描全表，每拿到一条数据库记录就与where条件比对，如果符合条件则将这条记录返回，重复直到全表扫描完毕。<br>在大数据量的情况下，不使用索引进行查询几乎是不可行的。</p>
<ul>
<li>使用UserID作为索引</li>
</ul>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/userId索引.png" alt=""><br>这时候看到where条件是使用了UserID索引的。这时候数据库引擎会根据UserID到索引上找到ID，然后根据ID去查询对应记录，从而取出ArriveDate数据。<br>现在我们将UserID的索引更换为UserID,ArriveDate的联合索引。<br>现在再来查询：<br><img src="http://7xkbey.com1.z0.glb.clouddn.com/useIDDate索引.png" alt=""><br>可以发现这个Extra里面也是使用了索引的，这就意味这个SQL是完全走了索引，数据库引擎根据UserID找到对应的索引， 因为Select的字段是索引的一部分，所以找到索引之后不需要再读取表记录了。</p>
<p>当一个查询语句中使用设计到多个索引时，MySQL数据库引擎会计算不同索引涉及到的行数大小，选取行数最小的索引作为实际执行时使用的索引，如：<br><img src="http://7xkbey.com1.z0.glb.clouddn.com/范围查询sql索引.png" alt=""><br><strong><font style="color:red">一次查询同一张表，MySQL每次只会使用一个索引。</font></strong></p>
<h4 id="2-2-索引在范围查询的使用"><a href="#2-2-索引在范围查询的使用" class="headerlink" title="2.2 索引在范围查询的使用"></a>2.2 索引在范围查询的使用</h4><p>范围查询主要是指查询字段值在某个范围内的记录，表现在where条件中为&gt;,&lt;,between等关键字。如，我们使用如下SQL进行查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> UserID,ArriveDate  <span class="keyword">from</span> TestSQL <span class="keyword">where</span> UserID &gt;<span class="number">0</span> <span class="keyword">and</span> UserID &lt;<span class="number">100</span>  <span class="keyword">and</span> ArriveDate = <span class="string">'2015-09-23 00:00:00'</span>;</span><br></pre></td></tr></table></figure></p>
<p>作为对比，我们使用另一种SQL查询相同记录：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> UserID,ArriveDate <span class="keyword">from</span> TestSQL <span class="keyword">where</span> UserID <span class="keyword">in</span>(<span class="number">2</span>,<span class="number">12</span>) <span class="keyword">and</span> ArriveDate = <span class="string">'2015-09-23 00:00:00'</span>;</span><br></pre></td></tr></table></figure></p>
<p>联调SQL都会查询出相同的记录：</p>
<table>
<thead>
<tr>
<th style="text-align:center">UserID</th>
<th style="text-align:center">ArriveDate</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2015-09-23 00:00:00</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">2015-09-23 00:00:00</td>
</tr>
</tbody>
</table>
<p>第一个SQL（使用范围查询）的explain结果为：</p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/范围查询sql索引.png" alt=""><br>第二个SQL（未使用范围查询）的explain结果为：</p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/范围查询sql索引.png" alt=""><br>对比可见，两种sql的索引长度是不一样的。在范围查询中，索引的使用是遵循最左（leftmost）原则，例如这个表的使用的索引是IX_UserID_ArriveDate，但是因为UserID使用了范围查询(Range query)，就不再使用ArrvieDate的索引了。</p>
<h4 id="2-3-排序使用索引"><a href="#2-3-排序使用索引" class="headerlink" title="2.3 排序使用索引"></a>2.3 排序使用索引</h4><p>在排序中以下情况无法使用索引：</p>
<ul>
<li>Order by 的字段并不是索引</li>
<li><p>使用了两种排序方向，但是索引都是使用升序排列的<br>  在索引的原理里我们讲到过</p>
<blockquote>
<p>如果索引是联合索引，比如UserID和AddTime索引的方式，索引叶子节点会存储UserID和AddTime之间的配对+主键的配对数据。</p>
</blockquote>
<p>  这种情况下，索引会以UserID进行排序，当UserID相同时再以AddTime进行排序（默认为升序），以我们现有的数据库为例：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> UserID,ArriveDate  <span class="keyword">from</span> TestSQL <span class="keyword">where</span> UserID <span class="keyword">in</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)   <span class="keyword">order</span> <span class="keyword">by</span> UserID <span class="keyword">asc</span>,ArriveDate <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>  这种情况将只使用UserID 作为索引，而ArriveDate 将不再作为索引。</p>
</li>
<li>不符合最左（Left most）的条件<pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">select</span> * <span class="keyword">from</span> TestSQL <span class="keyword">where</span>  ArriveDate =  <span class="string">'2015-09-23 00:00:00'</span> <span class="keyword">order</span> <span class="keyword">by</span> UserID <span class="keyword">desc</span></span><br><span class="line">    <span class="string">``</span><span class="string">`  </span><br><span class="line">    这种情况将不再使用UserID_ArriveDate索引</span><br><span class="line">- 联合查询的情况下，如果第一个筛选条件是范围查询，MySQL不再使用剩下的索引</span><br><span class="line"></span><br><span class="line">    `</span><span class="string">``</span><span class="keyword">sql</span></span><br><span class="line">    <span class="keyword">select</span> *  <span class="keyword">from</span> TestSQL <span class="keyword">where</span> UserID &gt;<span class="number">1</span> <span class="keyword">and</span> UserID &lt; <span class="number">5</span> <span class="keyword">order</span> <span class="keyword">by</span> UserID <span class="keyword">desc</span>,ArriveDate <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<p>这种情况下，因为UserID 为范围查询，所以就不会再使用ArriveDate 索引了。</p>
<h4 id="2-4-join-中使用索引"><a href="#2-4-join-中使用索引" class="headerlink" title="2.4 join 中使用索引"></a>2.4 join 中使用索引</h4><p>我们来新建一个TestSQL_join表，其结构与TestSQL 相同，但只有Mobile索引。首先来看一个简单的join操作<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TestSQL <span class="keyword">join</span> TestSQL_join <span class="keyword">on</span> TestSQL.id = TestSQL.id</span><br></pre></td></tr></table></figure></p>
<p>MySQL首先比较TestSQL和 TestSQL_join表那个行数少，如TestSQL中的记录较少，TestSQL就是一个小表，而TestSQL_join则是大表，MySQL引擎先把TestSQL中的ID全部去出来，然后根据id到TestSQL_join中查询相关的记录。</p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/join无where.png" alt=""></p>
<p>在这里，TestSQL中行数决定了循环的次数，但是TestSQL_join则决定了每次循环查询所需要查询的时间；这时如果TestSQL_join中的ID是索引则会大大减少查询时间如下SQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TestSQL a <span class="keyword">join</span> TestSQL_join b <span class="keyword">on</span> a.ID = b.ID</span><br></pre></td></tr></table></figure>
<p>由于b.ID 是TestSQL_join的主键，查询使用了TestSQL_join主键索引。<br><img src="http://7xkbey.com1.z0.glb.clouddn.com/join%20无索引.png" alt=""><br>如果此时对TestSQL增加条件筛选：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> TestSQL a <span class="keyword">join</span> TestSQL_join b <span class="keyword">on</span> a.ID = b.ID</span><br><span class="line"><span class="keyword">where</span> a.UserID = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>因为a.UserID 是TestSQL的索引，所以在过滤TestSQL表的行数时，采用次索引查询对应ID，然后根据ID查询TestSQL_join的记录。</p>
<p><img src="http://7xkbey.com1.z0.glb.clouddn.com/join使用索引过滤.png" alt=""><br>如果此时针对TestSQL_join 增加where条件过滤：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> TestSQL a <span class="keyword">join</span> TestSQL_join b <span class="keyword">on</span> a.ID = b.ID</span><br><span class="line"><span class="keyword">where</span> a.UserID &gt;<span class="number">1</span> <span class="keyword">and</span> b.Mobile = <span class="string">"2147483647"</span></span><br></pre></td></tr></table></figure></p>
<p>这种时候，因为TestSQL 和 TestSQL_join 根据where条件所筛选出来的行数大小可能会有变化，也就是说TestSQL_join 有可能会变成小表，这时候将会优先从TestSQL_join 查询出相关ID，然后根据ID去查询TestSQL。</p>
<p>join操作时，大表小表的概念，主要是按照两张表分别执行对应查询条件，哪个开销更小，哪个就是小表。</p>
<p><strong>join操作虽然在SQL层面很方便，而且在线上大流量的情况下，一旦SQL的join操作导致查询缓慢，较难即使优化。另外在服务化的系统中，容易导致业务领域不清晰，所以在互联网大流量的应用中是不推荐使用join操作的。</strong></p>
<h3 id="3-索引建立的原则"><a href="#3-索引建立的原则" class="headerlink" title="3. 索引建立的原则"></a>3. 索引建立的原则</h3><ul>
<li>使用区分度高的列作为索引<br>  区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，区分度越高，索引树的分叉也就越多，一次性找到的概率也就越高。</li>
<li>尽量使用字段长度小的列作为索引</li>
<li>使用数据类型简单的列（int 型，固定长度）</li>
<li><p>选用NOT NULL的列<br>  在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。</p>
</li>
<li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。这样也可避免索引重复。</p>
<h3 id="4-索引使用的原则"><a href="#4-索引使用的原则" class="headerlink" title="4. 索引使用的原则"></a>4. 索引使用的原则</h3></li>
<li>最左前缀匹配原则(leftmost)，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，=和in可以乱序，一个联合索引中，如UserID，ArriveDate的联合索引，使用ArriveDate in （）and UserID = 的任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式</li>
<li><p>索引列不能参与计算</p>
   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> TestSQL <span class="keyword">where</span> UserID + <span class="number">1</span> &gt;<span class="number">1</span> <span class="keyword">and</span> UserID &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>  这种方式UserID 的索引就不会再被使用，因为在进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。<br>另外当使用&lt;&gt;,like通配符放置在最前面 如：like’%ddd’ ,not, in, !=等运算符都不会使用索引。</p>
</li>
<li>查询数据库记录时，查询到的条目数尽量小，当通过索引获取到的数据库记录&gt; 数据库总揭露的1/3时，SQL将有可能直接全表扫描，索引就失去了应有的作用。</li>
</ul>
<h3 id="5-explain的使用"><a href="#5-explain的使用" class="headerlink" title="5. explain的使用"></a>5. explain的使用</h3><p>explain是MySQL查询优化过程的神器，详情可以查看<a href="http://dev.mysql.com/doc/refman/5.0/en/explain-output.html#explain-extra-information" target="_blank" rel="external">explain的使用</a></p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><blockquote>
<p>High Performance MySQL-THIRD EDITION<br><a href="http://dev.mysql.com/doc/refman/5.0/en/explain-output.html#explain-extra-information" target="_blank" rel="external">explain的使用</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA5NTQxNjA4NQ==&amp;mid=211982023&amp;idx=1&amp;sn=5bc45006475f63258f7ac78283e23781&amp;key=dffc561732c22651884a66f1d1ebe9536538747eec9accebae9bb52c3834bb1c9eee59714db6c3261df4f7e9b538d0db&amp;ascene=0&amp;uin=MjE5NTY4NQ%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27" target="_blank" rel="external">MySQL索引学习漫画</a><br><a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">MySQL索引原理及慢查询优化</a><br><a href="http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html" target="_blank" rel="external">理解MySQL——索引与优化</a><br><a href="http://www.cnblogs.com/kupig/archive/2011/10/19/2217228.html" target="_blank" rel="external">mysql索引的类型和优缺点</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/mysql-index-query/" data-id="cipak1vpa0005y95npd3o5jz6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL-Index-SQL/">MySQL Index SQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-undertow core.comments" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/undefined/" class="article-date">
  <time datetime="2015-08-23T12:56:27.000Z" itemprop="datePublished">2015-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>date: 2015-08-23 20:16:09<br>author: cjgnju<br>email: cjgnju@126.com<br>site:<br>ip: 45.116.12.222</p>
<p>ddddl</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/undefined/" data-id="cipak1vqa000ny95nitw7sn2s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-clojure/Clojure实现规则引擎" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/ruleengine-clojure-impments/" class="article-date">
  <time datetime="2015-08-16T08:39:00.000Z" itemprop="datePublished">2015-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/post/ruleengine-clojure-impments/">Clojure实现规则引擎</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h3><p>规则引擎由推理引擎发展而来，是一种嵌入在应用程序中的组件，实现了将业务决策从应用程序代码中分离出来，并使用预定义的语义模块编写业务决策。接受数据输入，解释业务规则，并根据业务规则做出业务决策。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when</span><br><span class="line">    &lt;conditions&gt;</span><br><span class="line">then</span><br><span class="line">    &lt;actions&gt;;</span><br></pre></td></tr></table></figure></p>
<p>最为著名的规则引擎是<a href="http://www.jboss.org/drools" target="_blank" rel="external">Drools</a>，现由JBoss维护，分为Guvnor，Expert，Jbpm5，Jbpm5和Planner五个模块，应用在jBPM工作流中。<br>目前Java中开源规则引擎也非常多，<a href="http://java-source.net/open-source/rule-engines" target="_blank" rel="external">Open Source Rule Engines in Java</a>，Java也已经指定了<a href="http://www.oracle.com/technetwork/articles/java/javarule-139829.html" target="_blank" rel="external">rule engine规范</a>。</p>
<h3 id="Clojure实现的规则引擎"><a href="#Clojure实现的规则引擎" class="headerlink" title="Clojure实现的规则引擎"></a>Clojure实现的规则引擎</h3><p>现在比较著名的规则引擎有：<br><a href="https://github.com/hraberg/mimir" target="_blank" rel="external">mimir</a>,这个library不牵涉到复杂的数据结构，使用起来也比较简单。<br><a href="https://github.com/rbrush/clara-rules" target="_blank" rel="external">clara</a>,与Drools比较相似，其目标是解绑业务逻辑，同时利用的Clojure和Java生态系统的优势表达其作为组合的规则，以控制业务复杂性；使用起来比较简单，可以很好的在分布式系统上运行。<br><a href="https://github.com/clojure/core.logic" target="_blank" rel="external">core.logic</a>,严格意义上不能算是<a href="https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E7%B7%A8%E7%A8%8B" target="_blank" rel="external">规则引擎</a>（<a href="https://en.wikipedia.org/wiki/Forward_chaining" target="_blank" rel="external">Forward chaining</a>范畴，实现了类似Prolog的逻辑编程（<a href="https://en.wikipedia.org/wiki/Backward_chaining" target="_blank" rel="external">Backward chaining</a>)。</p>
<h4 id="mimir-使用"><a href="#mimir-使用" class="headerlink" title="mimir 使用"></a>mimir 使用</h4><p>mimir是一个实验性的规则引擎，相对简单，截至现在已经2年多没有更新了，在这里也就不多介绍了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(rule xyz</span><br><span class="line">       X &lt; Y</span><br><span class="line">       Z &gt; 5</span><br><span class="line">       Z = (+ X Y)</span><br><span class="line">       Z != Y</span><br><span class="line">       =&gt;</span><br><span class="line">       (str X '+ Y '= Z))</span><br><span class="line"></span><br><span class="line"> (matches? "2+4=6"))</span><br></pre></td></tr></table></figure></p>
<p>这段代码是先指定了规则(rule)，然后判定一个fact是否满足该条件。</p>
<h4 id="clara-使用"><a href="#clara-使用" class="headerlink" title="clara 使用"></a>clara 使用</h4><p>clara的基本使用在<a href="https://github.com/rbrush/clara-examples" target="_blank" rel="external">clara-example</a>里面有很多示例。clara可以在Clojure,ClojureScript和Javay语言中使用。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defrule</span> free-lunch-with-gizmo</span><br><span class="line">  <span class="string">"Anyone who purchases a gizmo gets a free lunch."</span></span><br><span class="line">  [Purchase (<span class="name"><span class="builtin-name">=</span></span> item <span class="symbol">:gizmo</span>)]</span><br><span class="line">  =&gt;</span><br><span class="line">  (<span class="name">insert!</span> (<span class="name">-&gt;Promotion</span> <span class="symbol">:free-lunch-with-gizmo</span> <span class="symbol">:lunch</span>)))</span><br></pre></td></tr></table></figure></p>
<p>clara还提供了规则查询的功能<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defquery</span> get-promotions</span><br><span class="line">  <span class="string">"Query to find promotions for the purchase."</span></span><br><span class="line">  []</span><br><span class="line">  [?promotion &lt;- Promotion])</span><br></pre></td></tr></table></figure></p>
<h4 id="core-logic使用"><a href="#core-logic使用" class="headerlink" title="core.logic使用"></a>core.logic使用</h4><p>core.logic 严格来说是逻辑变成的范畴，过程是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事实 + 规则 =结果</span><br></pre></td></tr></table></figure></p>
<p>是通过目前已经符合条件的事实 和现有规则来推导符合该规则的条件，相比与规则引擎是一种反向过程。<br>例如：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">run*</span> [q]</span><br><span class="line">   (<span class="name">membero</span> q [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>])</span><br><span class="line">   (<span class="name">membero</span> q [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]))</span><br></pre></td></tr></table></figure></p>
<p>q满足了是[1 2 3]集合元素，又是 [2 3 4]的元素，计算q应该是什么。<br>core.logic主要采用一下方式：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">run*</span> [logic-variable]</span><br><span class="line">  &amp;logic-expressions)</span><br></pre></td></tr></table></figure></p>
<p>支持<strong>fresh</strong> <strong>unify</strong>, <strong>==</strong>等操作，默认条件是and操作，也可以通过conde支持OR操作。详细参见 <a href="https://github.com/clojure/core.logic/wiki/Features" target="_blank" rel="external">core.logic Features</a>。</p>
<h3 id="ruleengine"><a href="#ruleengine" class="headerlink" title="ruleengine"></a>ruleengine</h3><p>这是我为了练习Clojure而开的项目，结合了去年自己做优惠基础平台时的经验和想法的项目，目前还处于private状态。先写在这里，等到完成之后再公开项目。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><blockquote>
<p><a href="http://www.quora.com/How-can-Clojure-be-used-for-rules-engines" target="_blank" rel="external">Quora:How can Clojure be used for rules engines</a><br><a href="https://docs.jboss.org/drools/release/5.4.0.CR1/drools-expert-docs/html/ch01.html" target="_blank" rel="external">The Rule Engine</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/ruleengine-clojure-impments/" data-id="cipak3m2m0009ya5nr9wyiryv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Clojure-ruleengine/">Clojure ruleengine</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-undertow core" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/post/undertow-core/" class="article-date">
  <time datetime="2015-08-06T09:02:00.000Z" itemprop="datePublished">2015-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/post/undertow-core/">undertow core</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###XNIO<br>undertow 是以<a href="https://github.com/xnio/xnio" target="_blank" rel="external">XNIO</a>为实现核心。XNIO有两个核心概念：</p>
<p>####Channel<br>Channel，是传输管道的抽象概念，在NIO的Channel上进行的扩展加强，使用ChannelListener API进行事件通知。在创建Channel时，就赋予IO线程，用于执行所有的ChannelListener回调方法。</p>
<p>####IOWorker<br>区分IO线程和工作线程，创建一个工作线程池可以用来执行阻塞任务。一般情况下，非阻塞的Handler由IO线程执行，而阻塞任务比如Servlet则被调度到工作线程池执行。这样就很好的区分了阻塞和非阻塞的两种情形。</p>
<ul>
<li>WORKER_IO_THREADS, IO thread处理非阻塞任务，要保证不做阻塞操作，因为很多连接同时用到这类线程，类似于nodejs中的loop，这个线程只要有任务就去执行，实际配置时每个CPU一个线程比较好。</li>
<li>WORKER_TASK_CORE_THREADS，用于执行阻塞任务，从线程池中获得，任务完成后返回到线程池中。因为不同应用对应的服务器负载不同，所以不易给出具体数值，一般建议每个CPU core设置10个。</li>
</ul>
<p>我们知道NIO的基本要求是不阻塞当前线程的执行，对于非阻塞请求的结果，可以用两种方式获得：一种是对于请求很快返回一个引用（如JDK中Future，XNIO中称为IoFuture，其中很多方法是类似的），过一段时间再查询结果；还有一种是当结果就绪时，调用事先注册的回调方法来通知（如NIO2的CompletionHandler，XNIO的ChannelListener）。显而易见后者效率更高一些，避免了数据未就绪情景下的无用处理过程。但JDK7之前无法将函数作为方法参数，所以只能用Java的匿名内部类来模拟函数式方法，造成代码嵌套层次过多，难以理解和维护，所以Netty和XNIO这样的框架通过调度方法调用过程，简化了编程工作。</p>
<p>XNIO和Netty都对ByteBuffer进行池化管理，简单来说就是开发者在程序开始时就计划好读写缓存区大小，统一分配好放到池中，Xnio中有Pool和Pooled接口用来管理池化缓存区。开发过高并发应用就知道，JVM GC经常出现并难以控制是很头疼的问题。我们通常在接收网络数据时，往往简单的new出一块数据区，填充，解析，使用，最后丢弃，这种方法随着大量的数据读入，必然造成GC反复出现。重用缓存区就可以在这个方面解决一部分问题。</p>
<p>和Netty的ChannelHandler不同，XNIO对应的ChannelListener只有一个方法handleEvent()，也就意味着所有的事件都要经由这个方法。在实际实行过程中，会进行若干状态机的转变，比如在服务器端，开始时accept状态就绪，当连接建立后转变为可读或者可写状态。请参见下面的例子。</p>
<p>除了<strong>Channel</strong> 和 <strong>IOWorker</strong> 两个重要的基础，XNIO还提供了<strong>SSL支持</strong></p>
<h3 id="undertow-core"><a href="#undertow-core" class="headerlink" title="undertow core"></a>undertow core</h3><p>####Listeners<br>目前undertow中支持的Listner类型主要有</p>
<ul>
<li>HTTP</li>
<li>HTTPS</li>
<li>AJP</li>
<li>HTTP2</li>
</ul>
<p>####Handler<br>undertow原生提供了io.undertow.server.HttpHandler，接口定义比较简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServerExchange exchange)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>undertow中并没有pipeline的概念，但是可以在构建hanlder时指定next，如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetHeaderHandler</span> <span class="keyword">implements</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpString header;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpHandler next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetHeaderHandler</span><span class="params">(<span class="keyword">final</span> HttpHandler next, <span class="keyword">final</span> String header, <span class="keyword">final</span> String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.header = <span class="keyword">new</span> HttpString(header);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> HttpServerExchange exchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        exchange.getResponseHeaders().put(header, value);</span><br><span class="line">        next.handleRequest(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者类似下面的方式，只做自身逻辑的处理，不做传递：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterHandler</span> <span class="keyword">implements</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;DispatcherType, List&lt;ManagedFilter&gt;&gt; filters;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;DispatcherType, Boolean&gt; asyncSupported;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> allowNonStandardWrappers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpHandler next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterHandler</span><span class="params">(<span class="keyword">final</span> Map&lt;DispatcherType, List&lt;ManagedFilter&gt;&gt; filters, <span class="keyword">final</span> <span class="keyword">boolean</span> allowNonStandardWrappers, <span class="keyword">final</span> HttpHandler next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.allowNonStandardWrappers = allowNonStandardWrappers;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.filters = <span class="keyword">new</span> EnumMap&lt;&gt;(filters);</span><br><span class="line">        Map&lt;DispatcherType, Boolean&gt; asyncSupported = <span class="keyword">new</span> EnumMap&lt;&gt;(DispatcherType.class);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;DispatcherType, List&lt;ManagedFilter&gt;&gt; entry : filters.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> supported = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(ManagedFilter i : entry.getValue()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!i.getFilterInfo().isAsyncSupported()) &#123;</span><br><span class="line">                    supported = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            asyncSupported.put(entry.getKey(), supported);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.asyncSupported = asyncSupported;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> HttpServerExchange exchange)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ServletRequestContext servletRequestContext = exchange.getAttachment(ServletRequestContext.ATTACHMENT_KEY);</span><br><span class="line">        ServletRequest request = servletRequestContext.getServletRequest();</span><br><span class="line">        ServletResponse response = servletRequestContext.getServletResponse();</span><br><span class="line">        DispatcherType dispatcher = servletRequestContext.getDispatcherType();</span><br><span class="line">        Boolean supported = asyncSupported.get(dispatcher);</span><br><span class="line">        <span class="keyword">if</span>(supported != <span class="keyword">null</span> &amp;&amp; ! supported) &#123;</span><br><span class="line">            exchange.putAttachment(AsyncContextImpl.ASYNC_SUPPORTED, <span class="keyword">false</span>    );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;ManagedFilter&gt; filters = <span class="keyword">this</span>.filters.get(dispatcher);</span><br><span class="line">        <span class="keyword">if</span>(filters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.handleRequest(exchange);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> FilterChainImpl filterChain = <span class="keyword">new</span> FilterChainImpl(exchange, filters, next, allowNonStandardWrappers);</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>####组装服务器<br>1.创建XNIO Workder<br>2.创建 XNIO SSL实例<br>3.Create an instance of the relevant Undertow listener class<br>4.Open a server socket using XNIO and set its accept listener<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Xnio xnio = Xnio.getInstance();</span><br><span class="line">XnioWorker worker = xnio.createWorker(OptionMap.builder()</span><br><span class="line">        .set(Options.WORKER_IO_THREADS, ioThreads)</span><br><span class="line">        .set(Options.WORKER_TASK_CORE_THREADS, workerThreads)</span><br><span class="line">        .set(Options.WORKER_TASK_MAX_THREADS, workerThreads)</span><br><span class="line">        .set(Options.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .getMap());</span><br><span class="line">OptionMap socketOptions = OptionMap.builder()</span><br><span class="line">        .set(Options.WORKER_IO_THREADS, ioThreads)</span><br><span class="line">        .set(Options.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .set(Options.REUSE_ADDRESSES, <span class="keyword">true</span>)</span><br><span class="line">        .getMap();</span><br><span class="line">Pool&lt;ByteBuffer&gt; buffers = <span class="keyword">new</span> ByteBufferSlicePool(BufferAllocator.DIRECT_BYTE_BUFFER_ALLOCATOR,bufferSize, bufferSize * buffersPerRegion);</span><br><span class="line"><span class="keyword">if</span> (listener.type == ListenerType.AJP) &#123;</span><br><span class="line">    AjpOpenListener openListener = <span class="keyword">new</span> AjpOpenListener(buffers, serverOptions, bufferSize);</span><br><span class="line">    openListener.setRootHandler(rootHandler);</span><br><span class="line">    ChannelListener&lt;AcceptingChannel&lt;StreamConnection&gt;&gt; acceptListener = ChannelListeners.openListenerAdapter(openListener);</span><br><span class="line">    AcceptingChannel&lt;? extends StreamConnection&gt; server = worker.createStreamConnectionServer(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptions);</span><br><span class="line">    server.resumeAccepts();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (listener.type == ListenerType.HTTP) &#123;</span><br><span class="line">    HttpOpenListener openListener = <span class="keyword">new</span> HttpOpenListener(buffers, OptionMap.builder().set(UndertowOptions.BUFFER_PIPELINED_DATA, <span class="keyword">true</span>).addAll(serverOptions).getMap(), bufferSize);</span><br><span class="line">    openListener.setRootHandler(rootHandler);</span><br><span class="line">    ChannelListener&lt;AcceptingChannel&lt;StreamConnection&gt;&gt; acceptListener = ChannelListeners.openListenerAdapter(openListener);</span><br><span class="line">    AcceptingChannel&lt;? extends StreamConnection&gt; server = worker.createStreamConnectionServer(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), acceptListener, socketOptions);</span><br><span class="line">    server.resumeAccepts();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (listener.type == ListenerType.HTTPS)&#123;</span><br><span class="line">    HttpOpenListener openListener = <span class="keyword">new</span> HttpOpenListener(buffers, OptionMap.builder().set(UndertowOptions.BUFFER_PIPELINED_DATA, <span class="keyword">true</span>).addAll(serverOptions).getMap(), bufferSize);</span><br><span class="line">    openListener.setRootHandler(rootHandler);</span><br><span class="line">    ChannelListener&lt;AcceptingChannel&lt;StreamConnection&gt;&gt; acceptListener = ChannelListeners.openListenerAdapter(openListener);</span><br><span class="line">    XnioSsl xnioSsl;</span><br><span class="line">    <span class="keyword">if</span>(listener.sslContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        xnioSsl = <span class="keyword">new</span> JsseXnioSsl(xnio, OptionMap.create(Options.USE_DIRECT_BUFFERS, <span class="keyword">true</span>), listener.sslContext);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xnioSsl = xnio.getSslProvider(listener.keyManagers, listener.trustManagers, OptionMap.create(Options.USE_DIRECT_BUFFERS, <span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    AcceptingChannel &lt;SslConnection&gt; sslServer = xnioSsl.createSslConnectionServer(worker, <span class="keyword">new</span> InetSocketAddress(Inet4Address.getByName(listener.host), listener.port), (ChannelListener) acceptListener, socketOptions);</span><br><span class="line">    sslServer.resumeAccepts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###undertow servlet<br>类似与jetty，undertow 也可以部署采用部署war包的方式启动项目：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DeploymentInfo servletBuilder = Servlets.deployment()</span><br><span class="line">        .setClassLoader(ServletServer.class.getClassLoader())</span><br><span class="line">        .setContextPath(<span class="string">"/myapp"</span>)</span><br><span class="line">        .setDeploymentName(<span class="string">"test.war"</span>)</span><br><span class="line">        .addServlets(</span><br><span class="line">                Servlets.servlet(<span class="string">"MessageServlet"</span>, MessageServlet.class)</span><br><span class="line">                        .addInitParam(<span class="string">"message"</span>, <span class="string">"Hello World"</span>)</span><br><span class="line">                        .addMapping(<span class="string">"/*"</span>),</span><br><span class="line">                Servlets.servlet(<span class="string">"MyServlet"</span>, MessageServlet.class)</span><br><span class="line">                        .addInitParam(<span class="string">"message"</span>, <span class="string">"MyServlet"</span>)</span><br><span class="line">                        .addMapping(<span class="string">"/myservlet"</span>));</span><br><span class="line"></span><br><span class="line">DeploymentManager manager = Servlets.defaultContainer().addDeployment(servletBuilder);</span><br><span class="line">manager.deploy();</span><br><span class="line">PathHandler path = Handlers.path(Handlers.redirect(<span class="string">"/myapp"</span>))</span><br><span class="line">        .addPrefixPath(<span class="string">"/myapp"</span>, manager.start());</span><br><span class="line"></span><br><span class="line">Undertow server = Undertow.builder()</span><br><span class="line">        .addHttpListener(<span class="number">8080</span>, <span class="string">"localhost"</span>)</span><br><span class="line">        .setHandler(path)</span><br><span class="line">        .build();</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure></p>
<p>###Refernces</p>
<blockquote>
<p><a href="http://wildfly.iteye.com/blog/2040374" target="_blank" rel="external">Undertow服务器基础分析 - 概述</a><br><a href="http://wildfly.iteye.com/blog/2040377" target="_blank" rel="external">Undertow服务器基础分析 - XNIO</a><br><a href="http://wildfly.iteye.com/blog/2040380" target="_blank" rel="external">Undertow服务器基础分析</a><br><a href="http://undertow.io/undertow-docs/undertow-docs-1.2.0/index.html" target="_blank" rel="external">undertow cookdoc</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/post/undertow-core/" data-id="cipak1vqw000wy95nuyjmrwaw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Undertow/">Undertow</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/clojure/">clojure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/programing/">programing</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/summarize/">summarize</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术总结/">技术总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Clojure/">Clojure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Clojure-ruleengine/">Clojure ruleengine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Idempotent/">Idempotent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-JVM/">Java JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL-Index-SQL/">MySQL Index SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL-MySQL/">SQL MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Java/">Spring Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Undertow/">Undertow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/clojure-Compojure/">clojure Compojure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/front-end-cross-domian/">front-end, cross-domian</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcached/">memcached</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice/">microservice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/microservice-design-patterns/">microservice design-patterns</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rime-输入法/">rime,输入法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpc-pigeon/">rpc pigeon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scrum-敏捷-大项目管理/">scrum 敏捷 大项目管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态代码-Groovy-OGNL-SpEL-MVEL/">动态代码 Groovy OGNL SpEL MVEL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动静分离/">动静分离</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实时通信-comet-websocket/">实时通信 comet websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术总结/">技术总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/新年计划/">新年计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/管理/">管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/系统重构-设计模式/">系统重构 设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Clojure/" style="font-size: 20px;">Clojure</a> <a href="/tags/Clojure-ruleengine/" style="font-size: 10px;">Clojure ruleengine</a> <a href="/tags/Idempotent/" style="font-size: 10px;">Idempotent</a> <a href="/tags/Java-JVM/" style="font-size: 10px;">Java JVM</a> <a href="/tags/MySQL-Index-SQL/" style="font-size: 10px;">MySQL Index SQL</a> <a href="/tags/SQL-MySQL/" style="font-size: 10px;">SQL MySQL</a> <a href="/tags/Spring-Java/" style="font-size: 16.67px;">Spring Java</a> <a href="/tags/Undertow/" style="font-size: 13.33px;">Undertow</a> <a href="/tags/clojure-Compojure/" style="font-size: 10px;">clojure Compojure</a> <a href="/tags/front-end-cross-domian/" style="font-size: 10px;">front-end, cross-domian</a> <a href="/tags/memcached/" style="font-size: 10px;">memcached</a> <a href="/tags/microservice/" style="font-size: 10px;">microservice</a> <a href="/tags/microservice-design-patterns/" style="font-size: 10px;">microservice design-patterns</a> <a href="/tags/rime-输入法/" style="font-size: 10px;">rime,输入法</a> <a href="/tags/rpc-pigeon/" style="font-size: 10px;">rpc pigeon</a> <a href="/tags/scrum-敏捷-大项目管理/" style="font-size: 10px;">scrum 敏捷 大项目管理</a> <a href="/tags/动态代码-Groovy-OGNL-SpEL-MVEL/" style="font-size: 10px;">动态代码 Groovy OGNL SpEL MVEL</a> <a href="/tags/动静分离/" style="font-size: 10px;">动静分离</a> <a href="/tags/实时通信-comet-websocket/" style="font-size: 10px;">实时通信 comet websocket</a> <a href="/tags/技术总结/" style="font-size: 16.67px;">技术总结</a> <a href="/tags/新年计划/" style="font-size: 13.33px;">新年计划</a> <a href="/tags/管理/" style="font-size: 13.33px;">管理</a> <a href="/tags/系统重构-设计模式/" style="font-size: 10px;">系统重构 设计模式</a> <a href="/tags/转载/" style="font-size: 10px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">七月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">九月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/post/bigproj-in-scrum/">Scrum中大项目管理</a>
          </li>
        
          <li>
            <a href="/post/dynamic-code-in-java/">Java中使用动态代码</a>
          </li>
        
          <li>
            <a href="/post/system-reconstruct-summary/">业务系统重构总结</a>
          </li>
        
          <li>
            <a href="/post/service-design-patterns-practices/">服务化设计模式实践</a>
          </li>
        
          <li>
            <a href="/post/brower-server-msg/">浏览器与服务器的消息通信</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 陈景广<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>